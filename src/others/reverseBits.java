package others;

/**颠倒二进制位
 * 颠倒给定的 32 位无符号整数的二进制位。
 * 提示：
     请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
     在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。

 进阶:
    如果多次调用这个函数，你将如何优化你的算法？
 * Created by lll on 19/8/17.
 */
public class reverseBits {
    // 一开始想用常规方法依次首位交换1,但int和char无法转换,遂放弃;还是要用位运算

    /*方法一:
    1.将给定的二进制数,由低到高位逐个取出
    2.然后通过位运算将其放置到反转后的位置.
    3.将上述结果再次通过运算结合到一起
     */
    public int reverseBits1(int n) {
        int res = 0;
        for (int i=0; i<32; i++){
            int temp = (n>>i) & 1;//依次右移取最末的有效位
            temp <<= (31-i);//左移到翻转位置
            res |= temp;//组合起来
        }
        return res;
    }

    /*方法二:
    注意:前31位运算循环操作，最后一位字符不需要位移,组合即可
     */
    public int reverseBits2(int n) {
        int res = 0;
        for (int i=0; i<31; i++){
            res |= (n&1);//组合最末位
            n >>= 1;//n右移一位
            res <<=1;//res左移一位
        }
        return res |= (n&1);
    }

    /*
    Integer.reverse()源码
    十进制的例子，比如对数字12345678进行翻转，

    第一轮，相邻单一数字进行互换，结果为：
    21 43 65 87
    第二轮，以两个数字为一组交换相邻的，结果为：
    43 21 87 65
    第三轮，以四个数字为一组交换相邻的，结果为：
    8765 4321

    翻转完成。
     */
    public static int reverse(int i) {
        // HD, Figure 7-1
        i = (i & 0x55555555) << 1 | (i >>> 1) & 0x55555555;//相邻两个交换位置2
        i = (i & 0x33333333) << 2 | (i >>> 2) & 0x33333333;//相邻两两交换位置4
        i = (i & 0x0f0f0f0f) << 4 | (i >>> 4) & 0x0f0f0f0f;//相邻四四交换位置8
        i = (i << 24) | ((i & 0xff00) << 8) |
                ((i >>> 8) & 0xff00) | (i >>> 24);//相邻八八交换位置16及翻转前16和后16
        return i;
    }
}
